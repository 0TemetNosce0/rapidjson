<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>RapidJSON: SAX</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygenextra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="topbanner"><a href="https://github.com/miloyip/rapidjson" title="RapidJSON GitHub"><i class="githublogo"></i></a></div>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_doc_sax.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">SAX </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Reader">Reader</a><ul><li class="level2"><a href="#Handler">Handler</a></li>
<li class="level2"><a href="#GenericReader">GenericReader</a></li>
</ul>
</li>
<li class="level1"><a href="#Writer">Writer</a><ul><li class="level2"><a href="#PrettyWriter">PrettyWriter</a></li>
<li class="level2"><a href="#CompletenessReset">Completeness and Reset</a></li>
<li class="level2"><a href="#CustomDataStructure">Parsing JSON to Custom Data Structure</a></li>
<li class="level2"><a href="#Filtering">Filtering of JSON</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>The term "SAX" originated from <a href="http://en.wikipedia.org/wiki/Simple_API_for_XML">Simple API for XML</a>. We borrowed this term for JSON parsing and generation.</p>
<p>In RapidJSON, <code>Reader</code> (typedef of <code>GenericReader&lt;...&gt;</code>) is the SAX-style parser for JSON, and <code>Writer</code> (typedef of <code>GenericWriter&lt;...&gt;</code>) is the SAX-style generator for JSON.</p>
<h1><a class="anchor" id="Reader"></a>
Reader</h1>
<p><code>Reader</code> parses a JSON from a stream. While it reads characters from the stream, it analyze the characters according to the syntax of JSON, and publish events to a handler.</p>
<p>For example, here is a JSON.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">    <span class="stringliteral">&quot;hello&quot;</span>: <span class="stringliteral">&quot;world&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;t&quot;</span>: true ,</div>
<div class="line">    <span class="stringliteral">&quot;f&quot;</span>: <span class="keyword">false</span>,</div>
<div class="line">    <span class="stringliteral">&quot;n&quot;</span>: null,</div>
<div class="line">    <span class="stringliteral">&quot;i&quot;</span>: 123,</div>
<div class="line">    <span class="stringliteral">&quot;pi&quot;</span>: 3.1416,</div>
<div class="line">    <span class="stringliteral">&quot;a&quot;</span>: [1, 2, 3, 4]</div>
<div class="line">}</div>
</div><!-- fragment --><p>While a <code>Reader</code> parses this JSON, it publishes the following events to the handler sequentially:</p>
<div class="fragment"><div class="line">StartObject()</div>
<div class="line">Key(&quot;hello&quot;, 5, true)</div>
<div class="line">String(&quot;world&quot;, 5, true)</div>
<div class="line">Key(&quot;t&quot;, 1, true)</div>
<div class="line">Bool(true)</div>
<div class="line">Key(&quot;f&quot;, 1, true)</div>
<div class="line">Bool(false)</div>
<div class="line">Key(&quot;n&quot;, 1, true)</div>
<div class="line">Null()</div>
<div class="line">Key(&quot;i&quot;)</div>
<div class="line">UInt(123)</div>
<div class="line">Key(&quot;pi&quot;)</div>
<div class="line">Double(3.1416)</div>
<div class="line">Key(&quot;a&quot;)</div>
<div class="line">StartArray()</div>
<div class="line">Uint(1)</div>
<div class="line">Uint(2)</div>
<div class="line">Uint(3)</div>
<div class="line">Uint(4)</div>
<div class="line">EndArray(4)</div>
<div class="line">EndObject(7)</div>
</div><!-- fragment --><p>These events can be easily matched with the JSON, except some event parameters need further explanation. Let's see the <code>simplereader</code> example which produces exactly the same output as above:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="reader_8h.html">rapidjson/reader.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>rapidjson;</div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>MyHandler : <span class="keyword">public</span> <a class="code" href="structrapidjson_1_1_base_reader_handler.html">BaseReaderHandler</a>&lt;UTF8&lt;&gt;, MyHandler&gt; {</div>
<div class="line">    <span class="keywordtype">bool</span> Null() { cout &lt;&lt; <span class="stringliteral">&quot;Null()&quot;</span> &lt;&lt; endl; <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line">    <span class="keywordtype">bool</span> Bool(<span class="keywordtype">bool</span> b) { cout &lt;&lt; <span class="stringliteral">&quot;Bool(&quot;</span> &lt;&lt; boolalpha &lt;&lt; b &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; endl; <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line">    <span class="keywordtype">bool</span> Int(<span class="keywordtype">int</span> i) { cout &lt;&lt; <span class="stringliteral">&quot;Int(&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; endl; <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line">    <span class="keywordtype">bool</span> Uint(<span class="keywordtype">unsigned</span> u) { cout &lt;&lt; <span class="stringliteral">&quot;Uint(&quot;</span> &lt;&lt; u &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; endl; <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line">    <span class="keywordtype">bool</span> Int64(int64_t i) { cout &lt;&lt; <span class="stringliteral">&quot;Int64(&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; endl; <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line">    <span class="keywordtype">bool</span> Uint64(uint64_t u) { cout &lt;&lt; <span class="stringliteral">&quot;Uint64(&quot;</span> &lt;&lt; u &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; endl; <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line">    <span class="keywordtype">bool</span> Double(<span class="keywordtype">double</span> d) { cout &lt;&lt; <span class="stringliteral">&quot;Double(&quot;</span> &lt;&lt; d &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; endl; <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line">    <span class="keywordtype">bool</span> String(<span class="keyword">const</span> <span class="keywordtype">char</span>* str, <a class="code" href="namespacerapidjson.html#a44eb33eaa523e36d466b1ced64b85c84">SizeType</a> length, <span class="keywordtype">bool</span> copy) { </div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;String(&quot;</span> &lt;&lt; str &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; length &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; boolalpha &lt;&lt; copy &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; endl;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">bool</span> StartObject() { cout &lt;&lt; <span class="stringliteral">&quot;StartObject()&quot;</span> &lt;&lt; endl; <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line">    <span class="keywordtype">bool</span> Key(<span class="keyword">const</span> <span class="keywordtype">char</span>* str, <a class="code" href="namespacerapidjson.html#a44eb33eaa523e36d466b1ced64b85c84">SizeType</a> length, <span class="keywordtype">bool</span> copy) { </div>
<div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Key(&quot;</span> &lt;&lt; str &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; length &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; boolalpha &lt;&lt; copy &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; endl;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">bool</span> EndObject(<a class="code" href="namespacerapidjson.html#a44eb33eaa523e36d466b1ced64b85c84">SizeType</a> memberCount) { cout &lt;&lt; <span class="stringliteral">&quot;EndObject(&quot;</span> &lt;&lt; memberCount &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; endl; <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line">    <span class="keywordtype">bool</span> StartArray() { cout &lt;&lt; <span class="stringliteral">&quot;StartArray()&quot;</span> &lt;&lt; endl; <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line">    <span class="keywordtype">bool</span> EndArray(<a class="code" href="namespacerapidjson.html#a44eb33eaa523e36d466b1ced64b85c84">SizeType</a> elementCount) { cout &lt;&lt; <span class="stringliteral">&quot;EndArray(&quot;</span> &lt;&lt; elementCount &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; endl; <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main() {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> json[] = <span class="stringliteral">&quot; { \&quot;hello\&quot; : \&quot;world\&quot;, \&quot;t\&quot; : true , \&quot;f\&quot; : false, \&quot;n\&quot;: null, \&quot;i\&quot;:123, \&quot;pi\&quot;: 3.1416, \&quot;a\&quot;:[1, 2, 3, 4] } &quot;</span>;</div>
<div class="line"></div>
<div class="line">    MyHandler handler;</div>
<div class="line">    <a class="code" href="classrapidjson_1_1_generic_reader.html">Reader</a> reader;</div>
<div class="line">    <a class="code" href="structrapidjson_1_1_generic_string_stream.html">StringStream</a> ss(json);</div>
<div class="line">    reader.<a class="code" href="classrapidjson_1_1_generic_reader.html#ac9c540b77de19661f6f45e04b9b0937b">Parse</a>(ss, handler);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that, RapidJSON uses template to statically bind the <code>Reader</code> type and the handler type, instead of using class with virtual functions. This paradigm can improve the performance by inlining functions.</p>
<h2><a class="anchor" id="Handler"></a>
Handler</h2>
<p>As the previous example showed, user needs to implement a handler, which consumes the events (function calls) from <code>Reader</code>. The handler must contain the following member functions.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Handler {</div>
<div class="line">    <span class="keywordtype">bool</span> Null();</div>
<div class="line">    <span class="keywordtype">bool</span> Bool(<span class="keywordtype">bool</span> b);</div>
<div class="line">    <span class="keywordtype">bool</span> Int(<span class="keywordtype">int</span> i);</div>
<div class="line">    <span class="keywordtype">bool</span> Uint(<span class="keywordtype">unsigned</span> i);</div>
<div class="line">    <span class="keywordtype">bool</span> Int64(int64_t i);</div>
<div class="line">    <span class="keywordtype">bool</span> Uint64(uint64_t i);</div>
<div class="line">    <span class="keywordtype">bool</span> Double(<span class="keywordtype">double</span> d);</div>
<div class="line">    <span class="keywordtype">bool</span> RawNumber(<span class="keyword">const</span> Ch* str, <a class="code" href="namespacerapidjson.html#a44eb33eaa523e36d466b1ced64b85c84">SizeType</a> length, <span class="keywordtype">bool</span> copy);</div>
<div class="line">    <span class="keywordtype">bool</span> String(<span class="keyword">const</span> Ch* str, <a class="code" href="namespacerapidjson.html#a44eb33eaa523e36d466b1ced64b85c84">SizeType</a> length, <span class="keywordtype">bool</span> copy);</div>
<div class="line">    <span class="keywordtype">bool</span> StartObject();</div>
<div class="line">    <span class="keywordtype">bool</span> Key(<span class="keyword">const</span> Ch* str, <a class="code" href="namespacerapidjson.html#a44eb33eaa523e36d466b1ced64b85c84">SizeType</a> length, <span class="keywordtype">bool</span> copy);</div>
<div class="line">    <span class="keywordtype">bool</span> EndObject(<a class="code" href="namespacerapidjson.html#a44eb33eaa523e36d466b1ced64b85c84">SizeType</a> memberCount);</div>
<div class="line">    <span class="keywordtype">bool</span> StartArray();</div>
<div class="line">    <span class="keywordtype">bool</span> EndArray(<a class="code" href="namespacerapidjson.html#a44eb33eaa523e36d466b1ced64b85c84">SizeType</a> elementCount);</div>
<div class="line">};</div>
</div><!-- fragment --><p><code>Null()</code> is called when the <code>Reader</code> encounters a JSON null value.</p>
<p><code>Bool(bool)</code> is called when the <code>Reader</code> encounters a JSON true or false value.</p>
<p>When the <code>Reader</code> encounters a JSON number, it chooses a suitable C++ type mapping. And then it calls <em>one</em> function out of <code>Int(int)</code>, <code>Uint(unsigned)</code>, <code>Int64(int64_t)</code>, <code>Uint64(uint64_t)</code> and <code>Double(double)</code>. If <code>kParseNumbersAsStrings</code> is enabled, <code>Reader</code> will always calls <code>RawNumber()</code> instead.</p>
<p><code>String(const char* str, SizeType length, bool copy)</code> is called when the <code>Reader</code> encounters a string. The first parameter is pointer to the string. The second parameter is the length of the string (excluding the null terminator). Note that RapidJSON supports null character <code>\0</code> inside a string. If such situation happens, <code>strlen(str) &lt; length</code>. The last <code>copy</code> indicates whether the handler needs to make a copy of the string. For normal parsing, <code>copy = true</code>. Only when <em>insitu</em> parsing is used, <code>copy = false</code>. And beware that, the character type depends on the target encoding, which will be explained later.</p>
<p>When the <code>Reader</code> encounters the beginning of an object, it calls <code>StartObject()</code>. An object in JSON is a set of name-value pairs. If the object contains members it first calls <code>Key()</code> for the name of member, and then calls functions depending on the type of the value. These calls of name-value pairs repeats until calling <code>EndObject(SizeType memberCount)</code>. Note that the <code>memberCount</code> parameter is just an aid for the handler, user may not need this parameter.</p>
<p>Array is similar to object but simpler. At the beginning of an array, the <code>Reader</code> calls <code>BeginArary()</code>. If there is elements, it calls functions according to the types of element. Similarly, in the last call <code>EndArray(SizeType elementCount)</code>, the parameter <code>elementCount</code> is just an aid for the handler.</p>
<p>Every handler functions returns a <code>bool</code>. Normally it should returns <code>true</code>. If the handler encounters an error, it can return <code>false</code> to notify event publisher to stop further processing.</p>
<p>For example, when we parse a JSON with <code>Reader</code> and the handler detected that the JSON does not conform to the required schema, then the handler can return <code>false</code> and let the <code>Reader</code> stop further parsing. And the <code>Reader</code> will be in error state with error code <code>kParseErrorTermination</code>.</p>
<h2><a class="anchor" id="GenericReader"></a>
GenericReader</h2>
<p>As mentioned before, <code>Reader</code> is a typedef of a template class <code>GenericReader</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>rapidjson {</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SourceEncoding, <span class="keyword">typename</span> TargetEncoding, <span class="keyword">typename</span> Allocator = MemoryPoolAllocator&lt;&gt; &gt;</div>
<div class="line"><span class="keyword">class </span>GenericReader {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> GenericReader&lt;UTF8&lt;&gt;, UTF8&lt;&gt; &gt; <a class="code" href="namespacerapidjson.html#ad5310edd1226f5b3ea82dc0d4d3740c6">Reader</a>;</div>
<div class="line"></div>
<div class="line">} <span class="comment">// namespace rapidjson</span></div>
</div><!-- fragment --><p>The <code>Reader</code> uses UTF-8 as both source and target encoding. The source encoding means the encoding in the JSON stream. The target encoding means the encoding of the <code>str</code> parameter in <code>String()</code> calls. For example, to parse a UTF-8 stream and outputs UTF-16 string events, you can define a reader by:</p>
<div class="fragment"><div class="line">GenericReader&lt;UTF8&lt;&gt;, UTF16&lt;&gt; &gt; reader;</div>
</div><!-- fragment --><p>Note that, the default character type of <code>UTF16</code> is <code>wchar_t</code>. So this <code>reader</code>needs to call <code>String(const wchar_t*, SizeType, bool)</code> of the handler.</p>
<p>The third template parameter <code>Allocator</code> is the allocator type for internal data structure (actually a stack).</p>
<h2><a class="anchor" id=""></a>
</h2>
<p>The one and only one function of <code>Reader</code> is to parse JSON.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> parseFlags, <span class="keyword">typename</span> InputStream, <span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keywordtype">bool</span> Parse(InputStream&amp; is, Handler&amp; handler);</div>
<div class="line"></div>
<div class="line"><span class="comment">// with parseFlags = kDefaultParseFlags</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputStream, <span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keywordtype">bool</span> Parse(InputStream&amp; is, Handler&amp; handler);</div>
</div><!-- fragment --><p>If an error occurs during parsing, it will return <code>false</code>. User can also calls <code>bool HasParseEror()</code>, <code>ParseErrorCode GetParseErrorCode()</code> and <code>size_t GetErrorOffset()</code> to obtain the error states. Actually <code>Document</code> uses these <code>Reader</code> functions to obtain parse errors. Please refer to <a class="el" href="md_doc_dom.html">DOM</a> for details about parse error.</p>
<h1><a class="anchor" id="Writer"></a>
Writer</h1>
<p><code>Reader</code> converts (parses) JSON into events. <code>Writer</code> does exactly the opposite. It converts events into JSON.</p>
<p><code>Writer</code> is very easy to use. If your application only need to converts some data into JSON, it may be a good choice to use <code>Writer</code> directly, instead of building a <code>Document</code> and then stringifying it with a <code>Writer</code>.</p>
<p>In <code>simplewriter</code> example, we do exactly the reverse of <code>simplereader</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rapidjson/writer.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;rapidjson/stringbuffer.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>rapidjson;</div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main() {</div>
<div class="line">    <a class="code" href="classrapidjson_1_1_generic_string_buffer.html">StringBuffer</a> s;</div>
<div class="line">    <a class="code" href="classrapidjson_1_1_writer.html">Writer&lt;StringBuffer&gt;</a> writer(s);</div>
<div class="line"></div>
<div class="line">    writer.StartObject();</div>
<div class="line">    writer.Key(<span class="stringliteral">&quot;hello&quot;</span>);</div>
<div class="line">    writer.String(<span class="stringliteral">&quot;world&quot;</span>);</div>
<div class="line">    writer.Key(<span class="stringliteral">&quot;t&quot;</span>);</div>
<div class="line">    writer.Bool(<span class="keyword">true</span>);</div>
<div class="line">    writer.Key(<span class="stringliteral">&quot;f&quot;</span>);</div>
<div class="line">    writer.Bool(<span class="keyword">false</span>);</div>
<div class="line">    writer.Key(<span class="stringliteral">&quot;n&quot;</span>);</div>
<div class="line">    writer.Null();</div>
<div class="line">    writer.Key(<span class="stringliteral">&quot;i&quot;</span>);</div>
<div class="line">    writer.Uint(123);</div>
<div class="line">    writer.Key(<span class="stringliteral">&quot;pi&quot;</span>);</div>
<div class="line">    writer.Double(3.1416);</div>
<div class="line">    writer.Key(<span class="stringliteral">&quot;a&quot;</span>);</div>
<div class="line">    writer.StartArray();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; 4; i++)</div>
<div class="line">        writer.Uint(i);</div>
<div class="line">    writer.EndArray();</div>
<div class="line">    writer.EndObject();</div>
<div class="line"></div>
<div class="line">    cout &lt;&lt; s.GetString() &lt;&lt; endl;</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">{<span class="stringliteral">&quot;hello&quot;</span>:<span class="stringliteral">&quot;world&quot;</span>,<span class="stringliteral">&quot;t&quot;</span>:<span class="keyword">true</span>,<span class="stringliteral">&quot;f&quot;</span>:<span class="keyword">false</span>,<span class="stringliteral">&quot;n&quot;</span>:null,<span class="stringliteral">&quot;i&quot;</span>:123,<span class="stringliteral">&quot;pi&quot;</span>:3.1416,<span class="stringliteral">&quot;a&quot;</span>:[0,1,2,3]}</div>
</div><!-- fragment --><p>There are two <code>String()</code> and <code>Key()</code> overloads. One is the same as defined in handler concept with 3 parameters. It can handle string with null characters. Another one is the simpler version used in the above example.</p>
<p>Note that, the example code does not pass any parameters in <code>EndArray()</code> and <code>EndObject()</code>. An <code>SizeType</code> can be passed but it will be simply ignored by <code>Writer</code>.</p>
<p>You may doubt that, why not just using <code>sprintf()</code> or <code>std::stringstream</code> to build a JSON?</p>
<p>There are various reasons:</p><ol type="1">
<li><code>Writer</code> must output a well-formed JSON. If there is incorrect event sequence (e.g. <code>Int()</code> just after <code>StartObject()</code>), it generates assertion fail in debug mode.</li>
<li><code>Writer::String()</code> can handle string escaping (e.g. converting code point <code>U+000A</code> to <code>\n</code>) and Unicode transcoding.</li>
<li><code>Writer</code> handles number output consistently.</li>
<li><code>Writer</code> implements the event handler concept. It can be used to handle events from <code>Reader</code>, <code>Document</code> or other event publisher.</li>
<li><code>Writer</code> can be optimized for different platforms.</li>
</ol>
<p>Anyway, using <code>Writer</code> API is even simpler than generating a JSON by ad hoc methods.</p>
<h2><a class="anchor" id=""></a>
</h2>
<p><code>Writer</code> has a minor design difference to <code>Reader</code>. <code>Writer</code> is a template class, not a typedef. There is no <code>GenericWriter</code>. The following is the declaration.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>rapidjson {</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OutputStream, <span class="keyword">typename</span> SourceEncoding = UTF8&lt;&gt;, <span class="keyword">typename</span> TargetEncoding = UTF8&lt;&gt;, <span class="keyword">typename</span> Allocator = CrtAllocator&lt;&gt;, <span class="keywordtype">unsigned</span> writeFlags = kWriteDefaultFlags&gt;</div>
<div class="line"><span class="keyword">class </span>Writer {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code" href="classrapidjson_1_1_writer.html#a98a421c806b456688874511f64add1f2">Writer</a>(OutputStream&amp; os, Allocator* allocator = 0, <span class="keywordtype">size_t</span> levelDepth = kDefaultLevelDepth)</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">} <span class="comment">// namespace rapidjson</span></div>
</div><!-- fragment --><p>The <code>OutputStream</code> template parameter is the type of output stream. It cannot be deduced and must be specified by user.</p>
<p>The <code>SourceEncoding</code> template parameter specifies the encoding to be used in <code>String(const Ch*, ...)</code>.</p>
<p>The <code>TargetEncoding</code> template parameter specifies the encoding in the output stream.</p>
<p>The <code>Allocator</code> is the type of allocator, which is used for allocating internal data structure (a stack).</p>
<p>The <code>writeFlags</code> are combination of the following bit-flags:</p>
<table class="doxtable">
<tr>
<th>Parse flags </th><th>Meaning  </th></tr>
<tr>
<td><code>kWriteNoFlags</code> </td><td>No flag is set. </td></tr>
<tr>
<td><code>kWriteDefaultFlags</code> </td><td>Default write flags. It is equal to macro <code>RAPIDJSON_WRITE_DEFAULT_FLAGS</code>, which is defined as <code>kWriteNoFlags</code>. </td></tr>
<tr>
<td><code>kWriteValidateEncodingFlag</code> </td><td>Validate encoding of JSON strings. </td></tr>
<tr>
<td><code>kWriteNanAndInfFlag</code> </td><td>Allow writing of <code>Infinity</code>, <code>-Infinity</code> and <code>NaN</code>. </td></tr>
</table>
<p>Besides, the constructor of <code>Writer</code> has a <code>levelDepth</code> parameter. This parameter affects the initial memory allocated for storing information per hierarchy level.</p>
<h2><a class="anchor" id="PrettyWriter"></a>
PrettyWriter</h2>
<p>While the output of <code>Writer</code> is the most condensed JSON without white-spaces, suitable for network transfer or storage, it is not easily readable by human.</p>
<p>Therefore, RapidJSON provides a <code>PrettyWriter</code>, which adds indentation and line feeds in the output.</p>
<p>The usage of <code>PrettyWriter</code> is exactly the same as <code>Writer</code>, expect that <code>PrettyWriter</code> provides a <code>SetIndent(Ch indentChar, unsigned indentCharCount)</code> function. The default is 4 spaces.</p>
<h2><a class="anchor" id="CompletenessReset"></a>
Completeness and Reset</h2>
<p>A <code>Writer</code> can only output a single JSON, which can be any JSON type at the root. Once the singular event for root (e.g. <code>String()</code>), or the last matching <code>EndObject()</code> or <code>EndArray()</code> event, is handled, the output JSON is well-formed and complete. User can detect this state by calling <code>Writer::IsComplete()</code>.</p>
<p>When a JSON is complete, the <code>Writer</code> cannot accept any new events. Otherwise the output will be invalid (i.e. having more than one root). To reuse the <code>Writer</code> object, user can call <code>Writer::Reset(OutputStream&amp; os)</code> to reset all internal states of the <code>Writer</code> with a new output stream.</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
